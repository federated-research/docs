import { Callout } from "nextra/components";

# Five Safes TES - Ephemeral Credentials

## Summary

When a user submits a TES message via the Submission layer, the request is sent to create ephemeral credentials using the Camunda workflow. The corresponding process handler then create the credentials, stores them in the vault, and signal completion back to the TRE layer. The TRE layer then pulls credentials from the vault, injects them into TES executors as environment variables, which is then revoked using another camunda workflow either using the set timer for the credentials to expire or when a submission is cancelled.

The camunda workflows are defined using process models called **BPMN** and decision notations called **DMN**.

## BPMN and DMN Models:

### What BPMN means:

BPMN stands for Business Process Model and Notation. It’s a graphical way to define workflows that run inside Camunda or Zeebe. A BPMN file describes: - the flow of tasks, service calls, timers, subprocesses, and how errors or conditions move the flow forward.

In Five Safes TES, BPMN models define the lifecycle of credential creation and revocation. Every step that physically provisions, stores or revokes a credential appears as a BPMN Service Task, which maps directly to a C# job handler.

### What DMN means

DMN stands for Decision Model and Notation. It’s used to represent business rules or selection logic. 

Here, the credentials.dmn model decides which credential handlers (Postgres, MinIO, Trino or others) should run for a given submission.


### How BPMN/DMN deployment works in Camunda/Zeebe

1. BPMN and DMN files (process models) are stored inside the TRE-Camunda project.
2. On application startup, Zeebe’s client automatically deploys the models using client.deployResources. It can also be deployed using the Camunda Modeler interface using the rocket button shown in the bottom left corner.
3. Whenever the Submission layer triggers a process instance (eg TriggerStartCredentialsAsync), Zeebe uses the deployed BPMN definition to decide which jobs to create.

### How handlers connect to BPMN models

Each BPMN Service Task has a jobType attribute. Our C# handlers declare [JobType("create-postgres-user")], which links them to those BPMN tasks.

Currently, Five Safes TES uses BPMN models: - one for starting credential creation, one subprocess for determining which credentials to create, one for revocation.

DMN is used to control handler selection.


## BPMN and DMN models - Working

### Start Credentials (Start_Credentials.bpmn)

- **ServiceTask: Store Parent Process Instance Key**: Persists the root workflow instance key into the credentials DB. This is essential to persist the key to later on find the exact parent process instance key for the submission ID in the TRE layer to fetch the correct credentials and avoid duplicate entries into ephemeral credentials DB.
- **ServiceTask: Check success status**: Evaluates whether all credential handlers have succeeded or errored, driving completion.

<figure style={{ textAlign: 'center', paddingTop: '20px' }}>
  <img
    src="/images/start_credentials_bpmn.png"
    alt="Starting Credentials BPMN"
    width="700"
    style={{ display: "block", margin: "0 auto" }}
  />
    <figcaption style={{ fontStyle: 'italic', fontSize: '0.7em', marginTop: '8px' }}>
        Figure 1: illustrates Start Credentials BPMN workflow for process key storage and handler status validation.
    </figcaption>
</figure>

### Credentials Decision Model (credentials.dmn)

- DMN provides decision logic used by the parent BPMN workflow to determine which credential handlers should run based on input parameters (e.g. project type, user name, submissionId).


<figure style={{ textAlign: 'center', paddingTop: '20px' }}>
  <img
    src="/images/credentials_decision_model.png"
    alt="Credentials Decision Model"
    width="700"
    style={{ display: "block", margin: "0 auto" }}
  />
    <figcaption style={{ fontStyle: 'italic', fontSize: '0.7em', marginTop: '8px' }}>
        Figure 2: illustrates Credentials DMN for credential handler selection logic.
    </figcaption>
</figure>



### Determine Credentials Subprocess (Credentials_determine_sub.bpmn)

- **ServiceTask: postgres_credentials**: Invokes the Postgres credential creation handler (create-postgres-user). Additional handlers (MinIO, Trino) follow the same pattern when enabled. It also created a pre-defined path in vault where the credential information is stored safely and securely (explained in detail later).
- **ServiceTask: tre_credentials**: This handler is used to invoke the tre credentials handler that allows creation of other credentials in the future that is determined by the user in the DMN model. It acts as a default handler for types other than Postgres, Trino or MinIO.

<figure style={{ textAlign: 'center', paddingTop: '20px' }}>
  <img
    src="/images/credentials_determine_sub_bpmn.png"
    alt="Credentials Determine Subprocess BPMN"
    width="700"
    style={{ display: "block", margin: "0 auto" }}
  />
    <figcaption style={{ fontStyle: 'italic', fontSize: '0.7em', marginTop: '8px' }}>
        Figure 3: illustrates Determine Credentials Subprocess BPMN for invoking credential handlers and vault storage.
    </figcaption>
</figure>

### Postgres Handler (Call Postgres Credentials api):

The Postgres handler delegates credential provisioning to PostgreSQLUserManagementService.cs, which creates a new database user using the values extracted from the DMN output - such as username, database name, server, and port , to create a new user in Postgres. For manual administration and visibility, **Adminer** is used as the UI for Postgres.

<Callout type="info" title="Note">
    When configuring the connection string for the handler, ensure that the DB user specified has superuser privileges within the Postgres instance. This is required because the handler needs to create and manage new user accounts within the database which otherwise will not be possible with a non superuser. 
</Callout>

The handler currently creates a schema named after the project, and assigns the new user Read, Write, and Create Tables permissions on that schema. A simplified example of the request sent to the service looks like this:

```json copy

var createUserRequest = new CreateUserRequest

{

Username = username,

Password = password,

Server = server,

Datasbasename = database,

Port = port,

SchemaPermissions = schemaPermissions

};

var result = await _postgreSQLUserManagementService.CreateUserAsync(createUserRequest);

```


### Trino Handler(Call Trino Credentials api):

The Trino handler is a Zeebe job worker that delegates credential creation to LdapUserManagementService.cs That service opens a connection to the **OpenLDAP** directory and provisions a new user entry.

Trino user identities are backed by OpenLDAP, which is an open-source implementation of the Lightweight Directory Access Protocol (LDAP). For visibility and manual administration, **phpLDAPadmin** is used as the UI. Below is an example of an OpenLDAP user entry with the required attributes.

<figure style={{ textAlign: 'center', paddingTop: '20px' }}>
  <img
    src="/images/php_ldap_admin.png"
    alt="PHP LDAP Admin Interface"
    width="700"
    style={{ display: "block", margin: "0 auto" }}
  />
    <figcaption style={{ fontStyle: 'italic', fontSize: '0.7em', marginTop: '8px' }}>
        Figure 4: illustrates phpLDAPadmin interface displaying OpenLDAP user entry attributes for Trino credential management.
    </figcaption>
</figure>

## TRE Credentials Handler (Call TRE Credentials API)

This handler serves as a flexible extension point for **custom credential types** that fall outside the standard built‑ins (Postgres, MinIO, Trino). Whenever the DMN decision table determines that a submission requires one of these custom credential sets, the workflow routes into this handler through the subprocess.

It enables administrators to support new credential categories without touching BPMN logic or redeploying workflows. The only requirement is to update the DMN table with: - a unique credential type identifier, - the environment variables needed to construct or request that credential, - and any grouping or tagging information needed by the subprocess.

Once the DMN entry is present, the workflow can automatically call the TRE Credentials API to generate, manage and track the custom credentials.

### Revoke Credentials BPMN (Credentials_Revoke)

This BPMN model defines how TRE‑FX revokes/expires ephemeral credentials once they are no longer valid or when an explicit revoke request comes in.

<figure style={{ textAlign: 'center', paddingTop: '20px' }}>
  <img
    src="/images/revoke_credentials_bpmn.png"
    alt="Revoke Credentials BPMN"
    width="700"
    style={{ display: "block", margin: "0 auto" }}
  />
    <figcaption style={{ fontStyle: 'italic', fontSize: '0.7em', marginTop: '8px' }}>
        Figure 5: illustrates Revoke Credentials BPMN workflow for expiring ephemeral credentials upon invalidation or revocation requests.
    </figcaption>
</figure>


1. **Start Event – (RevokeCredentials)**

The process begins when an external service calls the webhook endpoint exposed by Camunda. The webhook payload includes fields like: - project - user - tag - submissionId - optional timer flags

2. **Credentials DMN Evaluation**

A multi‑instance Business Rule Task evaluates the credentials.dmn table for each record provided. This step determines which credential sets (Postgres, Trino, MinIO etc.) need to be revoked for the given user-project-tag.

3. **Gateway – Timer vs Immediate Revoke**

An Exclusive Gateway branches based on the timer value: - timer = 0 → Revoke credentials immediately, timer = 1 → Wait for the timer event before revoking.

4. **Credentials_expire_sub**

For each set it calls the **Credentials Expire Subprocess**, which performs the actual revocation via handler code.

Each revoke operation removes credentials from: - the target system (e.g. deleting a Postgres user, the Vault storage location, and updates EphemeralCredentials DB with the expiration time).

<figure style={{ textAlign: 'center', paddingTop: '20px' }}>
  <img
    src="/images/credentials_expire_sub.png"
    alt="Revoke Credentials BPMN"
    width="700"
    style={{ display: "block", margin: "0 auto" }}
  />
    <figcaption style={{ fontStyle: 'italic', fontSize: '0.7em', marginTop: '8px' }}>
        Figure 6: illustrates Credentials Expire Subprocess BPMN for removing credentials from target systems and updating expiration status.
    </figcaption>
</figure>


## High-level architecture

- **TRE (Admin layer):** Entry point for user submissions. Responsible for:
    - Triggering the Camunda workflow to *create* credentials for a submission.
    - Polling the internal credentials DB for ready credentials and fetching secrets from the vault.
    - Injecting found credentials into TES/TESK task executors as environment variables.
    - Triggering the *revoke* workflow after credentials are created (timer-based or on cancellation).

- **TRE-Camunda**: Orchestrates credential creation and revocation. It has different process handlers that handles the creation and revocation separately for the different types of credentials.

- **Vault:** Central secret storage where created credentials are stored with a pre-defined path ```(for example: postgres/{user}/{submissionId}/{project})```. The logic behind this setup is based in TRE-Camunda.

- **Credentials DB (EphemeralCredentials table):** Stores records after a successful credentials or details of errored credential creation so the TRE layer can coordinate polling and mark rows processed.

- **Credentials DB (EphemeralCredentials table)**: Stores records after a successful credentials or details of errored credential creation so the TRE layer can coordinate polling and mark rows processed.


## Sequence of events

1. Submission is created by the user.

2. The TRE layer triggers background hangfire jobs that enumerates waiting submissions and, for each, checks the EphemeralCredentials table to confirm it hasn't already triggered credential flow.

3. If not triggered, TriggerStartCredentialsAsync() is called that also passes the submissionID, projectID, user name as parameter, which is a call to the Start_Credentials webhook in Camunda. This starts a Camunda/Zeebe process instance for credential creation.

4. Camunda runs credential handler jobs. Example: create-postgres-user job is handled by CreatePostgresUserHandler.

5. Handler provisions credentials (calls Postgres user management or subsequent management service), stores values in Vault under a defined path, and writes a credentials-ready success record into EphemeralCredentials table.

6. The TRE layer (DoAgentWork.cs) polls EphemeralCredentials DB for unprocessed rows related to the submission ID and parent process instance key. When it finds all handlers have succeeded, it retrieves the credentials from the vault.

7. TRE layer injects credentials into TES executors environment variables and sends the TES task to TESK/Funnel as usual.

8. TRE then triggers **Revoke** workflow (the revoke timer inside the Camunda model will revoke after TTL). If the submission is being cancelled due to any issues, The REVOKE workflow is triggered instantly before having to wait for the TTL timer.



